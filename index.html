<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HongChen</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'holo-blue': '#00f3ff',
                        'holo-pink': '#bc13fe',
                    },
                    fontFamily: {
                        mono: ['Consolas', 'Monaco', 'SF Mono', 'monospace'],
                        sans: ['Arial Black', 'Impact', 'sans-serif']
                    }
                }
            }
        }
    </script>

    <!-- Import Map: 引入核心库 -->
    <script type="importmap">
    {
        "imports": {
            "react": "https://esm.sh/react@18.2.0",
            "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
            "three": "https://esm.sh/three@0.160.0",
            "three/addons/": "https://esm.sh/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <style>
        body { margin: 0; background-color: #050505; overflow: hidden; color: white; }
        
        /* 绝对居中覆盖层 */
        .ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; /* 让鼠标事件穿透到 Canvas */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }

        /* 名字故障特效 */
        .glitch-text {
            position: relative;
            font-size: 8vw;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: -0.05em;
            color: #fff;
            text-shadow: 2px 2px 0px #bc13fe, -2px -2px 0px #00f3ff;
            animation: glitch-skew 3s infinite linear alternate-reverse;
        }
        .glitch-text::before {
            content: attr(data-text);
            position: absolute;
            left: 0; top: 0;
            width: 100%; height: 100%;
            left: 2px; text-shadow: -1px 0 #ff00c1;
            clip: rect(44px, 450px, 56px, 0);
            animation: glitch-anim 5s infinite linear alternate-reverse;
        }
        .glitch-text::after {
            content: attr(data-text);
            position: absolute;
            left: 0; top: 0;
            width: 100%; height: 100%;
            left: -2px; text-shadow: -1px 0 #00fff9;
            clip: rect(44px, 450px, 56px, 0);
            animation: glitch-anim2 5s infinite linear alternate-reverse;
        }

        @keyframes glitch-anim {
            0% { clip: rect(12px, 9999px, 32px, 0); transform: skew(0.5deg); }
            5% { clip: rect(54px, 9999px, 10px, 0); transform: skew(0.1deg); }
            10% { clip: rect(22px, 9999px, 6px, 0); transform: skew(0.6deg); }
            100% { clip: rect(67px, 9999px, 82px, 0); transform: skew(0.2deg); }
        }
        @keyframes glitch-anim2 {
            0% { clip: rect(65px, 9999px, 100px, 0); transform: skew(0.3deg); }
            100% { clip: rect(2px, 9999px, 85px, 0); transform: skew(0.1deg); }
        }
        
        .sub-text {
            font-family: 'Consolas', monospace;
            background: rgba(0,0,0,0.6);
            padding: 5px 15px;
            border: 1px solid #333;
            backdrop-filter: blur(4px);
            margin-top: 1rem;
            letter-spacing: 0.2em;
        }

        /* 扫描线遮罩 */
        .scanlines {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.2) 50%, rgba(0,0,0,0.2));
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 20;
        }
        
        .vignette {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 50%, black 120%);
            pointer-events: none;
            z-index: 15;
        }
        
        .loading-overlay {
            position: fixed; inset: 0; background: #000; z-index: 100;
            display: flex; justify-content: center; align-items: center;
            color: #00f3ff; font-family: monospace;
            transition: opacity 1s ease;
        }
    </style>
</head>
<body>
    <!-- 加载层 -->
    <div id="loader" class="loading-overlay">
        <div>LOADING SHIN-CHAN'S WORLD... <span id="progress">0%</span></div>
    </div>

    <!-- React 挂载点 -->
    <div id="root"></div>

    <script type="module">
        import React, { useState, useEffect, useRef } from 'react';
        import { createRoot } from 'react-dom/client';
        import * as THREE from 'three';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        document.addEventListener('contextmenu', e => e.preventDefault());
        
        document.addEventListener('keydown', e => {
            if (e.key === 'F12' || 
                (e.ctrlKey && e.shiftKey && (e.key === 'I' || e.key === 'J' || e.key === 'C')) || 
                (e.ctrlKey && e.key === 'U')) {
                e.preventDefault();
            }
        });

        setInterval(() => {
            const startTime = performance.now();
            debugger;
            const endTime = performance.now();
            if (endTime - startTime > 100) {
                window.location.href = 'https://www.baidu.com';
            }
        }, 1000);

        const Scene3D = () => {
            const mountRef = useRef(null);

            useEffect(() => {
                // 1. 初始化场景
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0x110022); // 深紫色背景，配合蜡笔小新
                scene.fog = new THREE.FogExp2(0x110022, 0.02);

                // 2. 相机
                const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 0, 15); // 稍微拉远一点

                // 3. 渲染器
                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.toneMapping = THREE.ReinhardToneMapping;
                mountRef.current.appendChild(renderer.domElement);

                // 4. 后处理 (Bloom 发光特效)
                const renderScene = new RenderPass(scene, camera);
                const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
                bloomPass.threshold = 0;
                bloomPass.strength = 1.5;
                bloomPass.radius = 0.5;

                const composer = new EffectComposer(renderer);
                composer.addPass(renderScene);
                composer.addPass(bloomPass);

                // 5. 灯光
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                scene.add(ambientLight);

                const pointLight = new THREE.PointLight(0xffd700, 2, 100); // 金色光
                pointLight.position.set(5, 5, 5);
                scene.add(pointLight);

                const blueLight = new THREE.PointLight(0x00f3ff, 2, 100);
                blueLight.position.set(-5, -5, 5);
                scene.add(blueLight);

                // 6. 中央动画：赛博核心 (Cyber Core)
                const coreGroup = new THREE.Group();
                scene.add(coreGroup);

                // 内核：二十面体
                const coreGeo = new THREE.IcosahedronGeometry(1.5, 0);
                const coreMat = new THREE.MeshStandardMaterial({
                    color: 0x00f3ff,
                    metalness: 0.9,
                    roughness: 0.1,
                    emissive: 0x00f3ff,
                    emissiveIntensity: 0.5,
                    wireframe: true
                });
                const coreMesh = new THREE.Mesh(coreGeo, coreMat);
                coreGroup.add(coreMesh);

                // 外环：圆环
                const ringGeo = new THREE.TorusGeometry(2.5, 0.05, 16, 100);
                const ringMat = new THREE.MeshBasicMaterial({ color: 0xbc13fe, side: THREE.DoubleSide });
                const ringMesh = new THREE.Mesh(ringGeo, ringMat);
                coreGroup.add(ringMesh);
                
                // 第二外环
                const ringGeo2 = new THREE.TorusGeometry(3.2, 0.02, 16, 100);
                const ringMat2 = new THREE.MeshBasicMaterial({ color: 0xffd700 });
                const ringMesh2 = new THREE.Mesh(ringGeo2, ringMat2);
                ringMesh2.rotation.x = Math.PI / 2;
                coreGroup.add(ringMesh2);

                // 7. 3D 文字 (HongChen) - 移到底部
                const fontLoader = new FontLoader();
                const textMeshGroup = new THREE.Group();
                textMeshGroup.position.y = -3.5; // 移到底部
                scene.add(textMeshGroup);

                fontLoader.load('https://threejs.org/examples/fonts/helvetiker_bold.typeface.json', (font) => {
                    const text = 'HONGCHEN';
                    const colors = [0xff0000, 0xff7f00, 0xffff00, 0x00ff00, 0x00ffff, 0x0000ff, 0x8b00ff, 0xff1493];
                    
                    let xOffset = 0;
                    const letterSpacing = 0.2;
                    let totalWidth = 0;
                    const geometries = [];

                    text.split('').forEach((letter) => {
                        const geometry = new TextGeometry(letter, {
                            font: font, size: 0.8, height: 0.2, // 稍微缩小一点
                            curveSegments: 12, bevelEnabled: true, bevelThickness: 0.02, bevelSize: 0.01, bevelOffset: 0, bevelSegments: 3
                        });
                        geometry.computeBoundingBox();
                        const width = geometry.boundingBox.max.x - geometry.boundingBox.min.x;
                        geometries.push({ letter, geometry, width });
                        totalWidth += width + letterSpacing;
                    });
                    totalWidth -= letterSpacing;
                    
                    let currentX = -totalWidth / 2;

                    geometries.forEach((item, index) => {
                        const material = new THREE.MeshStandardMaterial({
                            color: colors[index % colors.length],
                            metalness: 0.8, roughness: 0.2,
                            emissive: colors[index % colors.length], emissiveIntensity: 0.2
                        });
                        const mesh = new THREE.Mesh(item.geometry, material);
                        mesh.position.set(currentX, 0, 0);
                        textMeshGroup.add(mesh);
                        currentX += item.width + letterSpacing;
                    });

                    const loader = document.getElementById('loader');
                    if(loader) {
                        loader.style.opacity = 0;
                        setTimeout(() => loader.remove(), 1000);
                    }
                });

                // 8. 粒子背景
                const particlesGeo = new THREE.BufferGeometry();
                const pCount = 2000;
                const pPos = new Float32Array(pCount * 3);
                for(let i=0; i<pCount*3; i++) {
                    pPos[i] = (Math.random() - 0.5) * 50;
                }
                particlesGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
                const particlesMat = new THREE.PointsMaterial({
                    size: 0.1, color: 0xffffff, transparent: true, opacity: 0.4
                });
                const particles = new THREE.Points(particlesGeo, particlesMat);
                scene.add(particles);

                // 9. 鼠标交互
                const mouse = new THREE.Vector2();
                const onMouseMove = (event) => {
                    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                };
                window.addEventListener('mousemove', onMouseMove);

                // 10. 动画循环
                const clock = new THREE.Clock();
                let delta = 0;
                
                const animate = () => {
                    requestAnimationFrame(animate);
                    const time = clock.getElapsedTime();
                    delta = clock.getDelta();

                    // 核心动画
                    coreMesh.rotation.x += delta * 0.5;
                    coreMesh.rotation.y += delta * 0.8;
                    
                    ringMesh.rotation.x += delta * 0.2;
                    ringMesh.rotation.y += delta * 0.2;
                    
                    ringMesh2.rotation.x += delta * 0.3;
                    ringMesh2.rotation.z -= delta * 0.1;

                    // 整个核心随鼠标微动
                    coreGroup.rotation.x = mouse.y * 0.2;
                    coreGroup.rotation.y = mouse.x * 0.2;

                    // 文字动画
                    if (textMeshGroup) {
                        textMeshGroup.rotation.y = Math.sin(time * 1.5) * 0.1;
                    }

                    particles.rotation.y = time * 0.02;
                    composer.render();
                };
                animate();
                const handleResize = () => {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                };
                window.addEventListener('resize', handleResize);

            return () => {
                window.removeEventListener('resize', handleResize);
                window.removeEventListener('mousemove', onMouseMove);
                if(mountRef.current) mountRef.current.innerHTML = '';
            };
        }, []);

        return React.createElement("div", { ref: mountRef, className: "fixed inset-0 z-0" });
    };

        const App = () => {
            const [activeLine, setActiveLine] = useState('line1');

            const lines = {
                line1: { ip: "192.140.186.169", label: "线路 1" },
                line2: { ip: "111.228.42.52", label: "线路 2" }
            };

            const links = [
                { name: "怪兽系列", port: "2174", color: "border-red-500 hover:bg-red-500/20 text-red-400" },
                { name: "独眼蛇系列", port: "7781", color: "border-green-500 hover:bg-green-500/20 text-green-400" },
                { name: "玩偶系列", port: "7885", color: "border-purple-500 hover:bg-purple-500/20 text-purple-400" },
                { name: "1H系列", port: "7780", color: "border-yellow-500 hover:bg-yellow-500/20 text-yellow-400" },
                { name: "778系列", port: "7779", color: "border-blue-500 hover:bg-blue-500/20 text-blue-400" },
                { name: "其他系列/K77/IE", port: "7888", color: "border-pink-500 hover:bg-pink-500/20 text-pink-400" },
                { name: "使用教程", url: "https://www.yuque.com/hongchen8/nrkptb?#《脚本教程》", color: "border-cyan-500 hover:bg-cyan-500/20 text-cyan-400" }
            ];

            return React.createElement("div", { className: "w-full h-screen relative overflow-hidden flex flex-col" },
                React.createElement(Scene3D),
                
                // 线路切换器 (顶部)
                React.createElement("div", { className: "absolute top-6 left-0 right-0 z-40 flex justify-center gap-4 pointer-events-auto px-4" },
                    Object.entries(lines).map(([key, info]) => 
                        React.createElement("button", {
                            key: key,
                            onClick: () => setActiveLine(key),
                            className: `
                                px-6 py-2 rounded-full font-bold tracking-wider transition-all duration-300
                                border shadow-lg backdrop-blur-sm
                                ${activeLine === key 
                                    ? 'bg-white text-black border-white shadow-[0_0_20px_rgba(255,255,255,0.5)] scale-105' 
                                    : 'bg-black/50 text-gray-400 border-gray-600 hover:bg-gray-800 hover:text-white'}
                            `
                        }, info.label)
                    )
                ),
                
                // 链接按钮层 (居中)
                React.createElement("div", { className: "absolute inset-0 z-30 flex flex-col justify-center items-center pointer-events-none p-4" },
                    // 状态提示
                    React.createElement("div", { className: "mb-6 text-center pointer-events-auto mt-12 md:mt-0" },
                         React.createElement("h2", { className: "text-xl md:text-3xl font-bold text-white drop-shadow-[0_0_10px_rgba(255,255,255,0.5)]" }, "SELECT GAME SERVER")
                    ),

                    React.createElement("div", { className: "grid grid-cols-1 sm:grid-cols-2 md:grid-cols-4 gap-4 md:gap-6 max-w-5xl w-full pointer-events-auto" },
                        links.map((link, index) => 
                            React.createElement("a", {
                                key: index,
                                href: link.url ? link.url : `http://${lines[activeLine].ip}:${link.port}`,
                                target: "_blank",
                                className: `
                                    group relative overflow-hidden
                                    backdrop-blur-md bg-black/40 
                                    border-2 ${link.color}
                                    p-4 md:p-6 rounded-xl
                                    flex items-center justify-center
                                    transition-all duration-300 ease-out
                                    hover:scale-105 hover:shadow-[0_0_30px_rgba(255,255,255,0.1)] hover:bg-black/60
                                    cursor-pointer no-underline
                                    min-h-[70px] md:min-h-[100px]
                                `
                            },
                                React.createElement("div", { className: "absolute inset-0 bg-gradient-to-r from-transparent via-white/10 to-transparent -translate-x-[200%] group-hover:translate-x-[200%] transition-transform duration-1000 ease-in-out" }),
                                React.createElement("span", { className: "text-lg md:text-2xl font-bold tracking-wider font-sans text-center break-words" }, link.name)
                            )
                        )
                    )
                ),

                // 视觉特效层
                React.createElement("div", { className: "scanlines" }),
                React.createElement("div", { className: "vignette" }),

                // UI 层 (底部文字遮罩)
                React.createElement("div", { className: "ui-layer" },
                    // 移除原来的中间文字，保留底部版权或其他信息
                )
            );
        };

        const root = createRoot(document.getElementById('root'));
        root.render(React.createElement(App));
    </script>
</body>
</html>